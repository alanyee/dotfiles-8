# -*- mode: sh -*-
ESHELL=$(iif '[ -n "$INSIDE_EMACS" ] && [ "$TERM" = "dumb" ]')

if ! "$ESHELL"; then
  ESHELL=$(iif '$REMOTE && [ "$TERM" = "dumb" ]')
fi

if has emacs && ! $REMOTE && silent emacsclient --eval "(progn t)"; then
  eclient="emacsclient"

  if $WINDOWS; then
    eclient="${eclient}w --server-file $HOME/.emacs.d/server/${EMACS_SERVER_FILE:-emacs-server-file}"
  fi

  set_editor "$eclient"
fi

path_remove() {
  PATH=${PATH//":$1:"/":"} # middle
  PATH=${PATH/#"$1:"/}     # beginning
  PATH=${PATH/%":$1"/}     # end
}

to_term() {
  cat <<EOF
  $1() {
    setsid sh -c "( $TERMINAL -e '$1 \$@'; elisp '(ns/spawn-terminal)')" &
    sleep 0.2
    elisp "(run-at-time 0 nil 'delete-frame)" >/dev/null
  }
EOF
}

# the elisp t is that we can reach emacs
if $ESHELL && silent elisp t; then
  succ .emacs.d/scripts
  PAGER="epager"

  for yeet in htop nethack cava; do
    if has $yeet; then
      eval "$(to_term $yeet)"
    fi
  done

  sxhkd() {
    path_remove "$HOME/.emacs.d/scripts"
    $(type -a sxhkd | sort | awk 'END{print $3}')
  }

  man() {
    elisp "(woman \"$*\") (Man-cleanup-manpage)"
  }

  clear() {
    elisp "(run-at-time 0 nil 'comint-clear-buffer)" >/dev/null
  }

  ranger() {
    elisp '(deer)'
  }

  # todo: if we are emacs and no background processes or anything
  # alias exit --> kill buffer

  # todo: sudo alias that can pass along PAGER var
  # maybe something else if we think of it too
fi
