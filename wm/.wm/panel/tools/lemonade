#!/usr/bin/env bash
#  Author: Mirko van der Waal, Nathan Isom
#  Mail: <mvdw at airmail dot cc>
#  Mail: <nathanisom27 at gmail.com dot cc>
#  Distributed under terms of the MIT license.
#
#  The MIT License (MIT)
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.

# notes on differences with captain
# takes 2 args, $conf and $geom

geometry=$2

# Obviously we set -e to quit at any error.
set -e

# auto-export variables
set -a

# Change the current directory to the lemonade directory always.
cd $(dirname $0)

lemonadedir=$HOME/.wm/panel
ident=$1$RANDOM

mkdir -p $lemonadedir $lemonadedir/logs $lemonadedir/lemons
exec 3<> $lemonadedir/logs/$ident.log

# Create the scripts directory.
lemons=$lemonadedir/lemons
juicer=$lemonadedir/juicers/$1

# The only bit of python in the code, we parse .dosini file with it.
source <(python3 -c "
import sys, re
from configparser import ConfigParser

def variable(*fmt):
    return '{}_{}={}'.format(*fmt)

def array(*fmt):
    return '{}_{}=({})'.format(*fmt)

# strict to false means you can have duplicate keys that override previous values.
parser = ConfigParser(strict=False)
parser.read(sys.argv[1])

for section in parser:
    for key in parser[section]:
        # Split on spaces and newlines to determine when to create arrays.
        # note: this means '^' can't be used in conf file.
        current = re.sub('[\n ]', '^', parser[section][key]).split('^')
        # Replace dashes with underscores for a better user experience.
        key = key.replace('-', '_')
        if len(current) == 1:
            print(variable(section, key, current[0]))
        else:
            print(array(section, key, ' '.join(current)))
" $juicer 2>&3) 2>&3

# "It is easier to port a shell than a shell script."
#   -- Larry Wall

process=/tmp/lemonade-process-$ident
unique=/tmp/lemonade-stack-$ident

# Always clean up when you are done.
trap "rm -f $unique $process; trap - TERM; kill 0" INT ERR TERM QUIT

# note enabled lemons.
for lemon in $(sed 's/:/ /g;s/|/ /g;' <<< $bar_format); do
    juicedLemons="$juicedLemons $lemon"
done

# transform format with delimiters and alignment
# todo: account for these as the bar is being made, not here..
# do so in an array mapped to name
i=0
for section in $(echo $bar_format | tr '|' '\n'); do
    case $i in
        0) position="$(echo "$section" | sed "s/:/${bar_left_delimiter}/g")${bar_left_append}" ;;
        1) position="${position}%{c}${bar_center_append_left}$(echo "$section" | sed "s/:/${bar_center_delimiter}/g")${bar_center_append_right}" ;;
        2) position="${position}%{r}${bar_right_append}$(echo "$section" | sed "s/:/${bar_right_delimiter}/g")" ;;
    esac
    i=$((i+1))
done

# build the panel switch
switch=""
for script in $juicedLemons; do
    position=$(sed "s/${script}/\$__${script}/g" <<< $position)
    switch="$switch ${script}) __${script}=\${line#*@} ;;"
done

# Retrieve a value from the stack, the stack is a collection of all scripts with
# unique sets of characters that are used for event handles.
stack() {
    {
    IFS=":" read -a char < <(grep -e "$1" < <(cat $unique))
    sed -i "/$1:/d" $unique
    echo "${char[0]}:${char[1]:1:$((${#char[1]} + 1))}" >> $unique
    echo ${char[1]:0:1}
    } 2>&3
}

# Catch the strings send to stdout and execute the matching command.
handle() {
    {
    while read -r line; do
        echo "${handle[$line]} &" &
    done
    } 2>&3
}

# Dynamically format all the available options and display them accordingly.
format() {
    {
    while read -r line; do
        eval "case ${line%%@*} in
            $switch
        esac ; echo \"$position\""
    done
    } 2>&3
}

# The defaults for the [bar] section. Most of the values are simplified and
# require some extra attention to be formatted correctly.
{
    declare -A bar=(
        [foreground]="#FFFFFFFF"
        [background]="#FF000000"
        [format]="||"
        [offset]=0
        [line]=2
        # padding inside sections
        [padding]=0

        [fonts]="monospace-9"
        [force]=true
        [class]="lemonbar"
        [clickables]=10
        [dock]="top")
    for section in "${!bar[@]}"; do
        if [[ $(eval "echo \${#bar_${section}}") -eq 0 ]]; then
            echo "No value for 'bar-$section' -> using ${bar[${section}]}"
            eval "bar_${section}=${bar[${section}]}"
        fi
    done
    for section in $juicedLemons; do
        printf "%s" "${section}:" {A..E} $'\n' >> $unique
    done
} 2>&3

# Whenever a value is not defined, set the default value for it.
{
    declare -A choices=(
        [foreground]="${bar_foreground}"
        [background]="${bar_background}"
        [overline]=false
        [underline]=false
        [activeoverline]=false
        [activeunderline]=false
        [line]=\#ff999999
        # todo: consider not having default 'active' things in this script.
        [activeline]=\#ffffffff
        [reload]=5)
    for name in $juicedLemons; do
        for section in "${!choices[@]}"; do
            if [[ $(eval "echo \${#${name}_${section}}") -eq 0 ]]; then
                echo "No value for '${name}-$section' -> using ${choices[${section}]}"
                eval "${name}_${section}=${choices[${section}]}"
            fi
        done
    done
} 2>&3

# Define what lines to draw (under & over), and what color they should be..
{
    declare -A line
    for name in $juicedLemons; do
        if [[ $(eval "echo \${#${name}_line}") -eq 0 ]]; then
            echo "No value for '${name}-line' -> using ${choices[foreground]}"
            eval "${name}_line=${choices[foreground]}"
        fi
        line["${name}"]="%{"
        for section in underline overline; do
            if [[ $(eval "echo \${${name}_${section}}") = true ]]; then
                line["${name}"]+="+${section:0:1}"
            else
                echo "No value for '${name}-${section}' -> using false"
            fi
        done
        line["${name}"]+="U$(eval "echo \${${name}_line}")}"
    done
} 2>&2

# Create event handles and add them in the area.
{
    declare -A area handle events=(
        [mouse_middle]=2
        [scroll_down]=5
        [mouse_right]=3
        [mouse_left]=1
        [scroll_up]=4)
    for name in $juicedLemons; do
        for event in ${!events[@]}; do
            if [[ ! -z $(eval "echo \${${name}_${event}}") ]]; then
                uid="$(stack ${name})${name}"
                handle["${uid}"]="$(eval "echo \${${name}_${event}}")"
                area["${name}_p"]+="%{A${events[$event]}:${uid}:}"
                area["${name}_s"]+="%{A}"
            else
                echo "No events specified for '${name}-${event/_/-}' -> using none."
            fi
        done
    done
} 2>&3

# Parse our previously collected elements to a full string.
{
    [[ -e "$process" ]] && rm "$process"
    mkfifo "$process"

    padding=
    for i in $(seq $bar_padding); do
        padding="$padding "
    done

    for name in $juicedLemons; do
        export juicedLemon="$name";
        if [[ ! -z $(eval "echo \${${name}_reload"}) ]]; then
            if [[ ! -z $(tr -d [:digit:]. <<< $(eval "echo \${${name}_reload"})) ]]; then
                hold=false;
                bar_message="${name}@"

                    while IFS=$'\n' read -r output; do
                        if [[ "${output:0:4}" == "meta" ]]; then
                            input="${output:4}"

                            if [ "$input" = "start" ]; then
                                hold=true
                            elif [ "$input" = "end" ]; then
                                hold=false
                            else
                                eval "$input"
                                continue
                            fi
                        else
                            if [[ ! -z "$output" ]]; then
                              bar_message="${bar_message}$(printf "%s" \
                                  "$(eval "echo \${area[${name}_p]"})" \
                                  "$(eval "echo \${line[${name}]"})" \
                                  "%{F$(eval "echo \${${name}_foreground}")}" \
                                  "%{B$(eval "echo \${${name}_background"})}" \
                                  "$padding" \
                                  "$output" \
                                  "$padding" \
                                  "%{F-}%{B-}" \
                                  "$(eval "echo \${area[${name}_s]"})" \
                                  "%{-o}%{-uU-}" \
                                  "$bar_center_delimiter")"
                                  # todo: make this dynamic, not center delim.
                            fi
                        fi

                        if ! $hold; then
                          printf "%s" \
                              "${bar_message}" \
                              $'\n' > "$process" &

                          bar_message="${name}@"
                        fi
                    done < <(eval "\${${name}_reload"} | "$lemons/$name") &
                else
                    while :; do
                        bar_message="${name}@"

                        while read -r output; do
                            bar_message="${bar_message}$(printf "%s" \
                                "$(eval "echo \${area[${name}_p]"})" \
                                "$(eval "echo \${line[${name}]"})" \
                                "%{F$(eval "echo \${${name}_foreground}")}" \
                                "%{B$(eval "echo \${${name}_background"})}" \
                                "$padding" \
                                "$output" \
                                "$padding" \
                                "%{F-}%{B-}" \
                                "$(eval "echo \${area[${name}_s]"})" \
                                "%{-o}%{-uU-}")"

                        done < <(eval "$lemons/$name")

                        printf "%s" \
                            "${bar_message}" \
                            $'\n' > "$process" &

                        sleep $(eval "echo \${${name}_reload"})
                    done > "$process" &
                fi
            fi
        done
    } 2>&3

echo lemonbar \
    $(printf " -f %s" "${bar_fonts[@]}") \
    $([[ $bar_force = true ]] && echo "-d") \
    -a $bar_clickables \
    -n "$bar_class" \
    -g $geometry -F "$bar_foreground" -B "$bar_background"

# Start lemonade

cat "$process" | format | eval lemonbar \
    $(printf " -f \"%s\"" "${bar_fonts[@]}") \
    $([[ $bar_force = true ]] && echo "-d") \
    -u $bar_line \
    -a $bar_clickables \
    -o $bar_offset \
    -n "$bar_class" \
    -g $geometry -F "\\$bar_foreground" -B "\\$bar_background" | handle | sh

wait
