#!/usr/bin/env bash
#  Author: Mirko van der Waal, Nathan Isom
#  Mail: <mvdw at airmail dot cc>
#  Mail: <nathanisom27 at gmail.com dot cc>
#  Distributed under terms of the MIT license.
#
#  The MIT License (MIT)
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.

# notes on differences with captain
# takes 2 args, $conf and $geom

geometry=$2

# Obviously we set -e to quit at any error.
set -e

# auto-export variables
set -a

# Change the current directory to the lemonade directory always.
cd $(dirname $([ -L $0  ] && readlink -f $0 || echo $0))

lemonadedir="$HOME/.wm/panel"
ident="$(bspc query -M -m "$mon" --names)"

mkdir -p $lemonadedir $lemonadedir/logs $lemonadedir/lemons
[ -f "$lemonadedir/logs/$ident.log" ] && rm "$lemonadedir/logs/$ident.log"
exec 3<> "$lemonadedir/logs/$ident.log"

# Create the scripts directory.
lemons=$lemonadedir/lemons
juicer=$lemonadedir/juicers/$1

# The only bit of python in the code, we parse .dosini file with it.
source <(python3 -c "
import sys, re
from configparser import ConfigParser

def variable(*fmt):
    return '{}_{}={}'.format(*fmt)

def array(*fmt):
    return '{}_{}=({})'.format(*fmt)

# strict to false means you can have duplicate keys that override previous values.
parser = ConfigParser(strict=False)
parser.read(sys.argv[1])

for section in parser:
    for key in parser[section]:
        # Split on spaces and newlines to determine when to create arrays.
        # note: this means '^' can't be used in conf file.
        current = re.sub('[\n ]', '^', parser[section][key]).split('^')
        # Replace dashes with underscores for a better user experience.
        key = key.replace('-', '_')
        if len(current) == 1:
            print(variable(section, key, current[0]))
        else:
            print(array(section, key, ' '.join(current)))
" $juicer 2>&3) 2>&3

# "It is easier to port a shell than a shell script."
#   -- Larry Wall

process=/tmp/lemonade-process-$ident
unique=/tmp/lemonade-stack-$ident

# Always clean up when you are done.
trap "error; rm -f $unique $process; trap - TERM; kill 0" INT ERR TERM QUIT



# note enabled lemons.
for lemon in $(sed 's/:/ /g;s/|/ /g;' <<< $bar_format); do
    juicedLemons="$juicedLemons $lemon"
done

# transform format with delimiters and alignment
# do so in an array mapped to name

#position="%{l}$(echo $bar_format | tr ':' ' ')"
position="%{l}$(echo $bar_format | sed "s/|/%{c}/;s/|/%{r}/;s/:/$bar_delimiter/g;")"

# build the panel switch
switch=""
for script in $juicedLemons; do
    position=$(sed "s/${script}/\$__${script}/g" <<< $position)
    switch="$switch ${script}) __${script}=\${line#*@} ;;"
done


# Retrieve a value from the stack, the stack is a collection of all scripts with
# unique sets of characters that are used for event handles.
stack() {
    {
    IFS=":" read -a char < <(grep -e "$1" < <(cat $unique))
    sed -i "/$1:/d" $unique
    echo "${char[0]}:${char[1]:1:$((${#char[1]} + 1))}" >> $unique
    echo ${char[1]:0:1}
    } 2>&3
}

# Catch the strings send to stdout and execute the matching command.
handle() {
    {
    while read -r line; do
        echo "${handle[$line]} &" &
    done
    } 2>&3
}

# Dynamically format all the available options and display them accordingly.
format() {
    {
    while read -r line; do
        eval "case ${line%%@*} in
            $switch
        esac ; echo \"$position\""
    done
    } 2>&3
}

# The defaults for the [bar] section. Most of the values are simplified and
# require some extra attention to be formatted correctly.
{
    declare -A bar=(
        [fg]="#FFFFFFFF"
        [bg]="#FF000000"
        [format]="||"
        [offset]=0
        [line]=2
        # padding inside sections
        [padding]=0

        [fonts]="monospace-9"
        [force]=true
        [class]="lemonbar"
        [clickables]=10
        [dock]="top")
    for section in "${!bar[@]}"; do
        if [[ $(eval "echo \${#bar_${section}}") -eq 0 ]]; then
            echo "No value for 'bar-$section' -> using ${bar[${section}]}"
            eval "bar_${section}=${bar[${section}]}"
        fi
    done
    for section in $juicedLemons; do
        printf "%s" "${section}:" {A..E} $'\n' >> $unique
    done
} 2>&3

# Whenever a value is not defined, set the default value for it.
{
    declare -A choices=(
        [fg]="${bar_fg}"
        [bg]="${bar_bg}"
        [overline]=false
        [underline]=false
        [line]=\#ff999999
        [activeline]=\#ffffffff
        [reload]=5)
    for name in $juicedLemons; do
        for section in "${!choices[@]}"; do
            if [[ $(eval "echo \${#${name}_${section}}") -eq 0 ]]; then
                echo "No value for '${name}-$section' -> using ${choices[${section}]}"
                eval "${name}_${section}=${choices[${section}]}"
            fi
        done
    done
} 2>&3

# Define what lines to draw (under & over), and what color they should be..
{
    declare -A line
    for name in $juicedLemons; do
        if [[ $(eval "echo \${#${name}_line}") -eq 0 ]]; then
            echo "No value for '${name}-line' -> using ${choices[fg]}"
            eval "${name}_line=${choices[fg]}"
        fi
        line["${name}"]="%{"
        for section in underline overline; do
            if [[ $(eval "echo \${${name}_${section}}") = true ]]; then
                line["${name}"]+="+${section:0:1}"
            else
                echo "No value for '${name}-${section}' -> using false"
            fi
        done
        line["${name}"]+="U$(eval "echo \${${name}_line}")}"
    done
} 2>&2

# Create event handles and add them in the area.
{
    declare -A area handle events=(
        [mouse_middle]=2
        [scroll_down]=5
        [mouse_right]=3
        [mouse_left]=1
        [scroll_up]=4)
    for name in $juicedLemons; do
        for event in ${!events[@]}; do
            if [[ ! -z $(eval "echo \${${name}_${event}}") ]]; then
                uid="$(stack ${name})${name}"
                handle["${uid}"]="$(eval "echo \${${name}_${event}}")"
                area["${name}_p"]+="%{A${events[$event]}:${uid}:}"
                area["${name}_s"]+="%{A}"
            else
                echo "No events specified for '${name}-${event/_/-}' -> using none."
            fi
        done
    done
} 2>&3

# Parse our previously collected elements to a full string.
{
    [[ -e "$process" ]] && rm "$process"
    mkfifo "$process"

    padding=
    for i in $(seq $bar_padding); do
        padding="$padding "
    done

    for name in $juicedLemons; do
        export juicedLemon="$name";
        if [[ ! -z $(eval "echo \${${name}_reload"}) ]]; then
            if [[ ! -z $(tr -d [:digit:]. <<< $(eval "echo \${${name}_reload"})) ]]; then
                hold=false;
                bar_message=

                    while IFS=$'\n' read -r output; do
                        if [[ "${output:0:4}" == "meta" ]]; then
                            eval "${output:4}"
                        else
                            if [[ ! -z "$output" ]]; then
                              bar_message="${bar_message}$(printf "%s" \
                                  "$(eval "echo \${area[${name}_p]"})" \
                                  "$(eval "echo \${line[${name}]"})" \
                                  "%{F$(eval "echo \${${name}_fg}")}" \
                                  "%{B$(eval "echo \${${name}_bg"})}" \
                                  "$padding" \
                                  "$output" \
                                  "$padding" \
                                  "%{F-}%{B-}" \
                                  "%{-o}%{-uU-}")"

                              if $hold; then
                                  bar_message="${bar_message}${bar_delimiter}"
                              fi
                            fi
                        fi

                        if ! $hold; then

                          printf "%s" \
                                 "${name}@" \
                                 "$(eval "echo \"\${${name}_prefix"}\")" \
                                 "${bar_message}" \
                                 "$(eval "echo \"\${${name}_suffix"}\")" \
                                 $'\n' > "$process"

                          bar_message=
                        fi
                    done < <(eval "\${${name}_reload"} | "$lemons/$name") &
                else
                    while true; do
                        while IFS=$'\n' read -r output; do
                            if [[ "${output:0:4}" == "meta" ]]; then
                                input="${output:4}"
                                eval "$input"
                            else
                                bar_message="$(printf "%s" \
                                    "$(eval "echo \${area[${name}_p]"})" \
                                    "$(eval "echo \${line[${name}]"})" \
                                    "%{F$(eval "echo \${${name}_fg}")}" \
                                    "%{B$(eval "echo \${${name}_bg"})}" \
                                    "${padding}" \
                                    "${output}" \
                                    "${padding}" \
                                    "%{F-}%{B-}" \
                                    "$(eval "echo \${area[${name}_s]"})" \
                                    "%{-o}%{-uU-}")"

                                #bar_message="${name}@${bar_message}"

                                printf "%s" \
                                       "${name}@" \
                                       "$(eval "echo \"\${${name}_prefix"}\")" \
                                       "${bar_message}" \
                                       "$(eval "echo \"\${${name}_suffix"}\")" \
                                       $'\n'
                            fi

                        done < <(eval "$lemons/$name")

                        sleep $(eval "echo \${${name}_reload"})
                    done > "$process" &
                fi
            fi
        done
    } 2>&3

# Start lemonade

cat "$process" | format | eval lemonbar \
    $(printf " -f \"%s\"" "${bar_fonts[@]}") \
    $([[ $bar_force = true ]] && echo "-d") \
    -u $bar_line \
    -a $bar_clickables \
    -o $bar_offset \
    -n "$bar_class" \
    -g $geometry -F "\\$bar_fg" -B "\\$bar_bg" | handle | sh

wait
